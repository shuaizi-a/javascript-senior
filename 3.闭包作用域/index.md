
## 案例解析
```javascript
let x = 5;
function fn(x){
	return fuction(y){
		console.log(y + (++x))
	}
}

let f = fn(6)
f(7)           //=> 14
fn(8)(9)       //=> 18
f(10)          //=> 18
console.log(x) //=> 5

```
> 一般情况下：函数执行完成之后，所执行的私有上下文都会出栈释放，私有上下文中的一切内容都会被销毁，优化栈内存空间

> 特殊情况：如果函数执行所形成的上下文当中，有一个东西（一般型的空间的地址）被当前上下文以以外的事物所占用，那么当前上下文是不能被出栈释放的，上下文中的信息保留下来(包含私有变量值)，导致栈内存空间变大

1 0 2
2 0 3

```javascript
let a = 0,
    b = 0;

function A(a){
    A = function(b){
        alert(a + b++)
    }
    alert(a++)
}

A(1)  //=> 1
A(2)  //=> 4 此刻内部的A被提出来了覆盖掉了外部的A，A里面的a变成了私有变量不会被释放
```